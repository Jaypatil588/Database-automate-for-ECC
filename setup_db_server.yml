---
# ============================================================================
# CONFIGURATION - Edit these values for your VM
# ============================================================================
- name: Setup SSH keys for hosts in inventory
  hosts: myhosts
  connection: local
  gather_facts: no
  vars:
    # SSH Connection Settings for initial key setup
    initial_ssh_user: "j"             # SSH username for initial key setup
    initial_ssh_password: "root"       # SSH password for initial key setup
    initial_ssh_port: 22               # SSH port (usually 22)
    
    # Database Settings
    db_root_password: "TheBetaSantaStore05!"
    base_ssh_users: ["root", "j"]
    users_json_path: "./users_to_create.json"
  
  tasks:
    - name: Get home directory
      shell: echo $HOME
      register: home_dir
      delegate_to: localhost
      changed_when: false

    - name: Set SSH key path
      set_fact:
        ssh_key_path: "{{ home_dir.stdout }}/.ssh/id_rsa_ansible_{{ inventory_hostname | replace('.', '_') }}"
      delegate_to: localhost

    - name: Check if SSH key exists for host
      stat:
        path: "{{ ssh_key_path }}"
      register: ssh_key_exists
      delegate_to: localhost

    - name: Generate SSH key pair for host if it doesn't exist
      openssh_keypair:
        path: "{{ ssh_key_path }}"
        type: rsa
        size: 2048
        comment: "ansible@{{ inventory_hostname }}"
      delegate_to: localhost
      when: not ssh_key_exists.stat.exists

    - name: Ensure .ssh directory has correct permissions (700)
      file:
        path: "{{ home_dir.stdout }}/.ssh"
        mode: '0700'
        state: directory
      delegate_to: localhost

    - name: Ensure private key has correct permissions (600)
      file:
        path: "{{ ssh_key_path }}"
        mode: '0600'
        state: file
      delegate_to: localhost

    - name: Ensure public key has correct permissions (644)
      file:
        path: "{{ ssh_key_path }}.pub"
        mode: '0644'
        state: file
      delegate_to: localhost

    - name: Read public key content for verification
      slurp:
        src: "{{ ssh_key_path }}.pub"
      register: public_key_content
      delegate_to: localhost


    - name: Check if SSH key already works
      shell: |
        ssh -i {{ ssh_key_path }} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -o ConnectTimeout=5 -p {{ initial_ssh_port }} {{ initial_ssh_user }}@{{ inventory_hostname }} 'echo "KEY_WORKS"' 2>&1
      delegate_to: localhost
      register: key_check
      changed_when: false
      failed_when: false

    - name: Get public key content as string
      set_fact:
        public_key_string: "{{ public_key_content.content | b64decode | trim }}"
      delegate_to: localhost

    - name: Add SSH key to authorized_keys on first login
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 30
        set exit_code 1
        log_user 0
        set pubkey "{{ public_key_string }}"
        spawn ssh -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no {{ initial_ssh_user }}@{{ inventory_hostname }} "mkdir -p ~/.ssh && echo \"$pubkey\" >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys && echo 'KEY_ADDED'"
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "KEY_ADDED" {
            set exit_code 0
          }
          timeout {
            set exit_code 1
          }
          eof {
            catch wait result
            set spawn_exit_code [lindex $result 3]
            if {$spawn_exit_code == 0} {
              set exit_code 0
            } elseif {$spawn_exit_code != ""} {
              set exit_code $spawn_exit_code
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: key_add_result
      changed_when: key_add_result.rc == 0
      failed_when: false
      when: "'KEY_WORKS' not in key_check.stdout | default('')"

    - name: Get absolute path for SSH private key
      shell: readlink -f {{ ssh_key_path }} || echo {{ ssh_key_path }}
      register: ssh_key_abs_path
      delegate_to: localhost
      changed_when: false

    - name: Update host variables for SSH key authentication
      add_host:
        name: "{{ inventory_hostname }}"
        ansible_host: "{{ inventory_hostname }}"
        ansible_ssh_private_key_file: "{{ ssh_key_abs_path.stdout }}"
        ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes'
        ansible_port: "{{ initial_ssh_port }}"
        ansible_user: "{{ initial_ssh_user }}"
        ansible_connection: ssh
        ansible_become: yes
        ansible_become_method: sudo
        ansible_become_password: "{{ initial_ssh_password }}"
        groups: myhosts
        db_root_password: "{{ db_root_password }}"
        base_ssh_users: "{{ base_ssh_users }}"
        users_json_path: "{{ users_json_path }}"

- name: Configure Rocky Linux VM as Database Server
  hosts: myhosts
  become: yes
  vars:
    db_root_password: "{{ hostvars[groups['myhosts'][0]]['db_root_password'] | default('TheBetaSantaStore05!') }}"
    base_ssh_users: "{{ hostvars[groups['myhosts'][0]]['base_ssh_users'] | default(['root']) }}"
    users_json_path: "{{ hostvars[groups['myhosts'][0]]['users_json_path'] | default('./users_to_create.json') }}"
  
  tasks:
    
    - name: Update package cache
      shell: dnf makecache -y
      register: dnf_cache_result
      changed_when: "'Metadata cache created' in dnf_cache_result.stdout or 'Metadata cache refreshed' in dnf_cache_result.stdout"
      failed_when: false

    - name: Show package cache update status
      debug:
        msg: "Package cache {{ 'updated' if dnf_cache_result.changed else 'already up to date' }}"

    - name: Install MariaDB server and client
      command: dnf install -y mariadb-server mariadb
      register: mariadb_install_result

    - name: Install Python 3 and MySQL client library
      command: dnf install -y python3 python3-pip python3-PyMySQL
      register: python_install_result

    - name: Start and enable MariaDB service
      systemd:
        name: mariadb
        state: started
        enabled: yes

    - name: Wait for MariaDB to be ready
      wait_for:
        port: 3306
        delay: 5
        timeout: 30

    - name: Check if server.cnf exists and is valid
      stat:
        path: /etc/my.cnf.d/server.cnf
      register: server_cnf_stat

    - name: Check if server.cnf has valid structure
      command: grep -q "^\[mysqld\]" /etc/my.cnf.d/server.cnf
      register: server_cnf_valid
      failed_when: false
      changed_when: false
      when: server_cnf_stat.stat.exists

    - name: Fix corrupted server.cnf file (remove if malformed)
      file:
        path: /etc/my.cnf.d/server.cnf
        state: absent
      when: server_cnf_stat.stat.exists and (server_cnf_valid.rc != 0 or server_cnf_stat.stat.size == 0)

    - name: Ensure server.cnf has proper [mysqld] section
      blockinfile:
        path: /etc/my.cnf.d/server.cnf
        block: |
          [mysqld]
          bind-address = 127.0.0.1
        marker: "# {mark} ANSIBLE MANAGED BLOCK"
        create: yes
        backup: yes
      notify: restart mariadb

    - name: Remove any malformed bind-address lines outside [mysqld] section
      lineinfile:
        path: /etc/my.cnf.d/server.cnf
        regexp: '^bind-address\s*='
        state: absent
      when: server_cnf_stat.stat.exists

    - name: Restart MariaDB if config was fixed
      systemd:
        name: mariadb
        state: restarted
      when: server_cnf_stat.stat.exists and (server_cnf_valid.rc != 0 or server_cnf_stat.stat.size == 0)
      register: mariadb_restarted

    - name: Wait for MariaDB after restart
      wait_for:
        port: 3306
        delay: 3
        timeout: 30
      when: mariadb_restarted.changed | default(false)

    - name: Set MariaDB root password (method 1 - using mysql command with escaped password)
      shell: |
        mysql -e 'ALTER USER "root"@"localhost" IDENTIFIED BY "{{ db_root_password }}"; FLUSH PRIVILEGES;'
      register: root_password_set
      changed_when: false
      no_log: true
      ignore_errors: yes

    - name: Verify root password works with password auth
      shell: |
        mysql -u root -p'{{ db_root_password }}' -e "SELECT 1;" 2>&1
      register: root_password_verify
      changed_when: false
      failed_when: false
      no_log: true

    - name: Enable unix_socket authentication for root (try mysql.global_priv first)
      shell: |
        mysql -u root -p'{{ db_root_password }}' -e "UPDATE mysql.global_priv SET priv=json_set(priv, '$.plugin', 'unix_socket') WHERE User='root' AND Host='localhost'; FLUSH PRIVILEGES;" 2>&1
      when: root_password_verify.rc == 0 or root_password_retry.changed | default(false)
      register: unix_socket_setup_global
      changed_when: false
      no_log: true
      ignore_errors: yes

    - name: Verify mysql works as root user (unix_socket)
      command: mysql -e "SELECT USER(), @@hostname;" 2>&1
      register: mysql_root_test
      changed_when: false
      failed_when: false

    - name: Ensure root can only login from localhost
      command: mysql -e "DELETE FROM mysql.user WHERE User='root' AND Host='{{ item }}'; FLUSH PRIVILEGES;"
      no_log: true
      changed_when: false
      loop:
        - "%"
        - "::1"
      ignore_errors: yes

    - name: Verify bind-address is set to 127.0.0.1
      command: grep -E "^bind-address\s*=\s*127.0.0.1" /etc/my.cnf.d/server.cnf
      register: bind_address_check
      changed_when: false
      failed_when: false

    - name: Verify MariaDB is listening on localhost only
      command: ss -tlnp | grep ":3306" | grep "127.0.0.1"
      register: mariadb_bind_check
      changed_when: false
      failed_when: false

    - name: Restart MariaDB if bind-address verification failed
      systemd:
        name: mariadb
        state: restarted
      when: bind_address_check.rc == 0 and mariadb_bind_check.rc != 0
      notify: restart mariadb

    # User and database creation is handled by the create_users role
    # Run with -e add_users=true to include user creation, or run create_users.yml separately

    - name: Backup SSH config before modification
      copy:
        src: /etc/ssh/sshd_config
        dest: /etc/ssh/sshd_config.backup.ansible
        remote_src: yes
      changed_when: false

    - name: Verify SSH config syntax
      command: sshd -t -f /etc/ssh/sshd_config
      register: ssh_config_verify
      changed_when: false
      failed_when: false

    - name: Restore SSH config if syntax check failed
      copy:
        src: /etc/ssh/sshd_config.backup.ansible
        dest: /etc/ssh/sshd_config
        remote_src: yes
      when: ssh_config_verify.rc != 0

    - name: Check if firewalld is running
      command: systemctl is-active firewalld
      register: firewalld_status
      changed_when: false
      failed_when: false
      when: ansible_os_family == "RedHat"

    - name: Ensure firewall allows SSH
      command: firewall-cmd --permanent --add-port={{ ansible_port | default(22) }}/tcp && firewall-cmd --reload
      when: 
        - ansible_os_family == "RedHat"
        - firewalld_status.rc == 0
      failed_when: false
      ignore_errors: yes

    - name: Ensure firewall blocks MariaDB from external access (MariaDB should not be exposed anyway)
      command: firewall-cmd --permanent --remove-port=3306/tcp 2>/dev/null; firewall-cmd --reload 2>/dev/null || true
      when: 
        - ansible_os_family == "RedHat"
        - firewalld_status.rc == 0
      changed_when: false
      failed_when: false

    - name: Final verification - Test MariaDB root access
      command: mysql -e "SELECT 'MariaDB is working correctly' AS status;"
      register: final_mariadb_test
      changed_when: false
      no_log: true

    # Conditionally include user creation role if add_users flag is set
    - name: Include create_users role
      include_role:
        name: create_users
      vars:
        users_json_path: "{{ hostvars[groups['myhosts'][0]]['users_json_path'] | default('./users_to_create.json') }}"
      when: add_users | default(false) | bool

    - name: Display final status
      debug:
        msg: |
          ========================================
          Database Server Setup Complete!
          ========================================
          Host: {{ inventory_hostname }}
          MariaDB Status: {{ 'OK' if final_mariadb_test.rc == 0 else 'FAILED - Check logs' }}
          ========================================
          Next steps:
          1. SSH into VM: ssh <user>@{{ inventory_hostname }}
          2. To create users and databases, run:
             ansible-playbook -i inventory_test.ini create_users.yml
             OR
             ansible-playbook -i inventory_test.ini setup_db_server.yml -e add_users=true

  handlers:
    - name: restart mariadb
      systemd:
        name: mariadb
        state: restarted

    - name: restart sshd
      systemd:
        name: sshd
        state: restarted
