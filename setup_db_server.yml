---
# ============================================================================
# CONFIGURATION - Edit these values for your VM
# ============================================================================
- name: Setup SSH keys for hosts in inventory
  hosts: myhosts
  connection: local
  gather_facts: no
  vars:
    # SSH Connection Settings for initial key setup
    initial_ssh_user: "j"             # SSH username for initial key setup
    initial_ssh_password: "root"       # SSH password for initial key setup
    initial_ssh_port: 22               # SSH port (usually 22)
    
    # Database Settings
    db_root_password: "TheBetaSantaStore05!"
    base_ssh_users: ["root"]
    users_json_path: "./users_to_create.json"
  
  tasks:
    - name: Get home directory
      shell: echo $HOME
      register: home_dir
      delegate_to: localhost
      changed_when: false

    - name: Set SSH key path
      set_fact:
        ssh_key_path: "{{ home_dir.stdout }}/.ssh/id_rsa_ansible_{{ inventory_hostname | replace('.', '_') }}"
      delegate_to: localhost

    - name: Check if SSH key exists for host
      stat:
        path: "{{ ssh_key_path }}"
      register: ssh_key_exists
      delegate_to: localhost

    - name: Generate SSH key pair for host if it doesn't exist
      openssh_keypair:
        path: "{{ ssh_key_path }}"
        type: rsa
        size: 2048
        comment: "ansible@{{ inventory_hostname }}"
      delegate_to: localhost
      when: not ssh_key_exists.stat.exists

    - name: Ensure .ssh directory has correct permissions (700)
      file:
        path: "{{ home_dir.stdout }}/.ssh"
        mode: '0700'
        state: directory
      delegate_to: localhost

    - name: Ensure private key has correct permissions (600)
      file:
        path: "{{ ssh_key_path }}"
        mode: '0600'
        state: file
      delegate_to: localhost

    - name: Ensure public key has correct permissions (644)
      file:
        path: "{{ ssh_key_path }}.pub"
        mode: '0644'
        state: file
      delegate_to: localhost

    - name: Read public key content for verification
      slurp:
        src: "{{ ssh_key_path }}.pub"
      register: public_key_content
      delegate_to: localhost

    - name: Test SSH password authentication before copying key
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 10
        set exit_code 1
        log_user 0
        spawn ssh -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no -o ConnectTimeout=5 {{ initial_ssh_user }}@{{ inventory_hostname }} "echo PASSWORD_TEST_SUCCESS"
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "PASSWORD_TEST_SUCCESS" {
            set exit_code 0
          }
          -re "Permission denied" {
            puts "ERROR: Password authentication failed - please verify the password for {{ initial_ssh_user }}@{{ inventory_hostname }}"
            set exit_code 1
          }
          timeout {
            puts "ERROR: Connection timed out - please verify host is accessible"
            set exit_code 1
          }
          eof {
            catch wait result
            if {[lindex $result 3] != 0} {
              set exit_code [lindex $result 3]
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: password_test_result
      changed_when: false
      failed_when: password_test_result.rc != 0

    - name: Copy SSH key to host using password authentication
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 60
        set exit_code 1
        log_user 0
        spawn ssh-copy-id -i {{ ssh_key_path }}.pub -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no {{ initial_ssh_user }}@{{ inventory_hostname }}
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "Number of key.*added:" {
            set exit_code 0
            exp_continue
          }
          -re "(?i)already exists" {
            set exit_code 0
            exp_continue
          }
          -re "(?i)skipped.*already exist" {
            set exit_code 0
            exp_continue
          }
          -re "(?i)WARNING.*skipped" {
            set exit_code 0
            exp_continue
          }
          -re "Permission denied" {
            puts "ERROR: Permission denied - password may be incorrect"
            set exit_code 1
            exp_continue
          }
          -re "ERROR" {
            set exit_code 1
            exp_continue
          }
          timeout {
            puts "ERROR: ssh-copy-id timed out"
            set exit_code 1
          }
          eof {
            catch wait result
            set spawn_exit_code [lindex $result 3]
            if {$spawn_exit_code == 0} {
              set exit_code 0
            } elseif {$spawn_exit_code != ""} {
              set exit_code $spawn_exit_code
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: ssh_key_copy_result
      changed_when: "'already exists' not in ssh_key_copy_result.stdout | default('') and 'skipped' not in ssh_key_copy_result.stdout | default('') and ssh_key_copy_result.rc == 0"
      failed_when: ssh_key_copy_result.rc != 0
      when: password_test_result.rc == 0

    - name: Get public key content as string
      set_fact:
        public_key_string: "{{ public_key_content.content | b64decode | trim }}"
      delegate_to: localhost

    - name: Fix host-side permissions using password authentication
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 30
        set exit_code 1
        log_user 0
        spawn ssh -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no {{ initial_ssh_user }}@{{ inventory_hostname }} "mkdir -p ~/.ssh && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys 2>/dev/null; echo 'PERMISSIONS_FIXED'"
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "PERMISSIONS_FIXED" {
            set exit_code 0
          }
          timeout {
            set exit_code 1
          }
          eof {
            catch wait result
            if {[lindex $result 3] != 0} {
              set exit_code [lindex $result 3]
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: permissions_fix_result
      changed_when: false
      failed_when: permissions_fix_result.rc != 0
      when: ssh_key_copy_result is defined

    - name: Manual key copy fallback if expect script failed
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 30
        set exit_code 1
        log_user 0
        set pubkey "{{ public_key_string }}"
        spawn ssh -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no {{ initial_ssh_user }}@{{ inventory_hostname }} "mkdir -p ~/.ssh && chmod 700 ~/.ssh && echo \"$pubkey\" >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys && echo 'KEY_COPIED'"
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "KEY_COPIED" {
            set exit_code 0
          }
          timeout {
            set exit_code 1
          }
          eof {
            catch wait result
            if {[lindex $result 3] != 0} {
              set exit_code [lindex $result 3]
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: manual_key_copy_result
      changed_when: manual_key_copy_result.rc == 0
      failed_when: manual_key_copy_result.rc != 0
      when: ssh_key_copy_result.rc != 0

    - name: Verify SSH server allows PubkeyAuthentication
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 30
        set exit_code 1
        log_user 0
        spawn ssh -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no {{ initial_ssh_user }}@{{ inventory_hostname }} "grep -E '^PubkeyAuthentication|^#PubkeyAuthentication' /etc/ssh/sshd_config | tail -1"
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "PubkeyAuthentication yes" {
            set exit_code 0
          }
          -re "PubkeyAuthentication no" {
            set exit_code 1
          }
          timeout {
            set exit_code 1
          }
          eof {
            catch wait result
            if {[lindex $result 3] != 0} {
              set exit_code [lindex $result 3]
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: pubkey_auth_check
      changed_when: false
      failed_when: false

    - name: Enable PubkeyAuthentication if disabled
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 30
        set exit_code 1
        log_user 0
        spawn ssh -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no {{ initial_ssh_user }}@{{ inventory_hostname }} "sed -i 's/^#PubkeyAuthentication.*/PubkeyAuthentication yes/' /etc/ssh/sshd_config && sed -i 's/^PubkeyAuthentication no/PubkeyAuthentication yes/' /etc/ssh/sshd_config && systemctl restart sshd && echo 'SSHD_RESTARTED'"
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "SSHD_RESTARTED" {
            set exit_code 0
          }
          timeout {
            set exit_code 1
          }
          eof {
            catch wait result
            if {[lindex $result 3] != 0} {
              set exit_code [lindex $result 3]
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: pubkey_auth_enable
      changed_when: pubkey_auth_enable.rc == 0
      failed_when: false
      when: pubkey_auth_check.rc != 0

    - name: Test SSH key connection before proceeding
      shell: |
        ssh -i {{ ssh_key_path }} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -p {{ initial_ssh_port }} {{ initial_ssh_user }}@{{ inventory_hostname }} 'echo "SSH_KEY_CONNECTION_SUCCESS"'
      delegate_to: localhost
      register: ssh_key_test
      changed_when: false
      failed_when: ssh_key_test.rc != 0 or 'SSH_KEY_CONNECTION_SUCCESS' not in ssh_key_test.stdout | default('')

    - name: Get absolute path for SSH private key
      shell: readlink -f {{ ssh_key_path }} || echo {{ ssh_key_path }}
      register: ssh_key_abs_path
      delegate_to: localhost
      changed_when: false

    - name: Update host variables for SSH key authentication
      add_host:
        name: "{{ inventory_hostname }}"
        ansible_host: "{{ inventory_hostname }}"
        ansible_ssh_private_key_file: "{{ ssh_key_abs_path.stdout }}"
        ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes'
        ansible_port: "{{ initial_ssh_port }}"
        ansible_user: "{{ initial_ssh_user }}"
        ansible_connection: ssh
        ansible_become: yes
        ansible_become_method: sudo
        ansible_become_password: "{{ initial_ssh_password }}"
        groups: myhosts
        db_root_password: "{{ db_root_password }}"
        base_ssh_users: "{{ base_ssh_users }}"
        users_json_path: "{{ users_json_path }}"

    - name: Ping check to verify connection
      shell: |
        ssh -i {{ ssh_key_abs_path.stdout }} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -p {{ initial_ssh_port }} {{ initial_ssh_user }}@{{ inventory_hostname }} 'echo "pong"'
      delegate_to: localhost
      register: ping_result
      changed_when: false
      failed_when: ping_result.rc != 0 or 'pong' not in ping_result.stdout | default('')

- name: Configure Rocky Linux VM as Database Server
  hosts: myhosts
  become: yes
  vars:
    db_root_password: "{{ hostvars[groups['myhosts'][0]]['db_root_password'] | default('TheBetaSantaStore05!') }}"
    base_ssh_users: "{{ hostvars[groups['myhosts'][0]]['base_ssh_users'] | default(['root']) }}"
    users_json_path: "{{ hostvars[groups['myhosts'][0]]['users_json_path'] | default('./users_to_create.json') }}"
  
  tasks:
    
    - name: Update package cache
      shell: dnf makecache -y
      register: dnf_cache_result
      changed_when: "'Metadata cache created' in dnf_cache_result.stdout or 'Metadata cache refreshed' in dnf_cache_result.stdout"
      failed_when: false

    - name: Show package cache update status
      debug:
        msg: "Package cache {{ 'updated' if dnf_cache_result.changed else 'already up to date' }}"
    
    - name: Update all packages (this may take 10-30 minutes)
      shell: dnf update -y
      register: dnf_update_result
      failed_when: false  # Don't fail if update times out

    - name: Show package update summary
      debug:
        msg: "Package update task completed. Check output above for details."

    - name: Install MariaDB server and client
      shell: dnf install -y mariadb-server mariadb
      register: mariadb_install_result

    - name: Install Python 3 and MySQL client library
      shell: dnf install -y python3 python3-pip python3-PyMySQL
      register: python_install_result

    - name: Start and enable MariaDB service
      systemd:
        name: mariadb
        state: started
        enabled: yes

    - name: Wait for MariaDB to be ready
      wait_for:
        port: 3306
        delay: 5
        timeout: 30

    - name: Check if server.cnf exists and is valid
      stat:
        path: /etc/my.cnf.d/server.cnf
      register: server_cnf_stat

    - name: Check if server.cnf has valid structure
      command: grep -q "^\[mysqld\]" /etc/my.cnf.d/server.cnf
      register: server_cnf_valid
      failed_when: false
      changed_when: false
      when: server_cnf_stat.stat.exists

    - name: Fix corrupted server.cnf file (remove if malformed)
      file:
        path: /etc/my.cnf.d/server.cnf
        state: absent
      when: server_cnf_stat.stat.exists and (server_cnf_valid.rc != 0 or server_cnf_stat.stat.size == 0)

    - name: Ensure server.cnf has proper [mysqld] section
      blockinfile:
        path: /etc/my.cnf.d/server.cnf
        block: |
          [mysqld]
          bind-address = 127.0.0.1
        marker: "# {mark} ANSIBLE MANAGED BLOCK"
        create: yes
        backup: yes
      notify: restart mariadb

    - name: Remove any malformed bind-address lines outside [mysqld] section
      lineinfile:
        path: /etc/my.cnf.d/server.cnf
        regexp: '^bind-address\s*='
        state: absent
      when: server_cnf_stat.stat.exists

    - name: Restart MariaDB if config was fixed
      systemd:
        name: mariadb
        state: restarted
      when: server_cnf_stat.stat.exists and (server_cnf_valid.rc != 0 or server_cnf_stat.stat.size == 0)
      register: mariadb_restarted

    - name: Wait for MariaDB after restart
      wait_for:
        port: 3306
        delay: 3
        timeout: 30
      when: mariadb_restarted.changed | default(false)

    - name: Set MariaDB root password (method 1 - using mysql command with escaped password)
      shell: |
        mysql -e 'ALTER USER "root"@"localhost" IDENTIFIED BY "{{ db_root_password }}"; FLUSH PRIVILEGES;'
      register: root_password_set
      changed_when: false
      no_log: true
      ignore_errors: yes

    - name: Verify root password works with password auth
      shell: |
        mysql -u root -p'{{ db_root_password }}' -e "SELECT 1;" 2>&1
      register: root_password_verify
      changed_when: false
      failed_when: false
      no_log: true

    - name: Set MariaDB root password (method 2 - if method 1 failed)
      shell: |
        mysql -e 'SET PASSWORD FOR "root"@"localhost" = PASSWORD("{{ db_root_password }}"); FLUSH PRIVILEGES;'
      when: root_password_verify.rc != 0
      register: root_password_retry
      changed_when: false
      no_log: true
      ignore_errors: yes

    - name: Enable unix_socket authentication for root (try mysql.global_priv first)
      shell: |
        mysql -u root -p'{{ db_root_password }}' -e "UPDATE mysql.global_priv SET priv=json_set(priv, '$.plugin', 'unix_socket') WHERE User='root' AND Host='localhost'; FLUSH PRIVILEGES;" 2>&1
      when: root_password_verify.rc == 0 or root_password_retry.changed | default(false)
      register: unix_socket_setup_global
      changed_when: false
      no_log: true
      ignore_errors: yes

    - name: Enable unix_socket authentication for root (fallback to mysql.user if global_priv failed)
      shell: |
        mysql -u root -p'{{ db_root_password }}' -e "UPDATE mysql.user SET plugin='unix_socket' WHERE user='root' AND host='localhost'; FLUSH PRIVILEGES;" 2>&1
      when: 
        - (root_password_verify.rc == 0 or root_password_retry.changed | default(false))
        - unix_socket_setup_global.rc != 0
      register: unix_socket_setup
      changed_when: false
      no_log: true
      ignore_errors: yes

    - name: Verify mysql works as root user (unix_socket)
      command: mysql -e "SELECT USER(), @@hostname;" 2>&1
      register: mysql_root_test
      changed_when: false
      failed_when: false

    - name: Remove anonymous users
      command: mysql -e "DELETE FROM mysql.user WHERE User=''; FLUSH PRIVILEGES;"
      no_log: true
      changed_when: false

    - name: Remove test database
      command: mysql -e "DROP DATABASE IF EXISTS test;"
      no_log: true
      changed_when: false
      ignore_errors: yes

    - name: Ensure root can only login from localhost
      command: mysql -e "DELETE FROM mysql.user WHERE User='root' AND Host='{{ item }}'; FLUSH PRIVILEGES;"
      no_log: true
      changed_when: false
      loop:
        - "%"
        - "::1"
      ignore_errors: yes

    - name: Verify bind-address is set to 127.0.0.1
      command: grep -E "^bind-address\s*=\s*127.0.0.1" /etc/my.cnf.d/server.cnf
      register: bind_address_check
      changed_when: false
      failed_when: false

    - name: Verify MariaDB is listening on localhost only
      command: ss -tlnp | grep ":3306" | grep "127.0.0.1"
      register: mariadb_bind_check
      changed_when: false
      failed_when: false

    - name: Restart MariaDB if bind-address verification failed
      systemd:
        name: mariadb
        state: restarted
      when: bind_address_check.rc == 0 and mariadb_bind_check.rc != 0
      notify: restart mariadb

    - name: Read user data from JSON file
      set_fact:
        student_users: "{{ lookup('file', users_json_path) | from_json }}"
      delegate_to: localhost
      run_once: true

    - name: Create system users
      ansible.builtin.user:
        name: "{{ item.key }}"
        password: "{{ item.value | password_hash('sha512') }}"
        shell: /bin/bash
        create_home: yes
        state: present
      with_dict: "{{ student_users }}"
      ignore_errors: yes

    - name: Create database and DB user
      command: mysql -e "CREATE DATABASE IF NOT EXISTS {{ item.key }};"
      with_dict: "{{ student_users }}"
      register: db_creation_result
      changed_when: "'already exists' not in db_creation_result.stdout | default('')"

    - name: Verify databases were created
      command: mysql -e "SHOW DATABASES LIKE '{{ item.key }}';"
      register: db_verify
      changed_when: false
      failed_when: false
      no_log: true
      with_dict: "{{ student_users }}"

    - name: Create MariaDB users with localhost access only
      shell: |
        mysql -e "CREATE USER IF NOT EXISTS '{{ item.key }}'@'localhost' IDENTIFIED BY '{{ item.value }}';"
        mysql -e "GRANT ALL PRIVILEGES ON {{ item.key }}.* TO '{{ item.key }}'@'localhost';"
      with_dict: "{{ student_users }}"
      register: user_creation_result
      no_log: true

    - name: Verify MariaDB users were created
      command: mysql -e "SELECT user, host FROM mysql.user WHERE user='{{ item.key }}' AND host='localhost';"
      register: user_verify
      changed_when: false
      failed_when: false
      no_log: true
      with_dict: "{{ student_users }}"

    - name: Flush MySQL privileges
      command: mysql -e "FLUSH PRIVILEGES;"
      changed_when: false
      no_log: true

    - name: Get all student usernames
      set_fact:
        student_usernames: "{{ student_users.keys() | list }}"

    - name: Backup SSH config before modification
      copy:
        src: /etc/ssh/sshd_config
        dest: /etc/ssh/sshd_config.backup.ansible
        remote_src: yes
      changed_when: false

    - name: Configure SSH AllowUsers
      ansible.builtin.lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^AllowUsers'
        line: "AllowUsers {{ (base_ssh_users + student_usernames) | join(' ') }}"
        validate: 'sshd -t -f %s'
        backup: yes
      register: ssh_config_result
      notify: restart sshd

    - name: Verify SSH config syntax
      command: sshd -t -f /etc/ssh/sshd_config
      register: ssh_config_verify
      changed_when: false
      failed_when: false

    - name: Restore SSH config if syntax check failed
      copy:
        src: /etc/ssh/sshd_config.backup.ansible
        dest: /etc/ssh/sshd_config
        remote_src: yes
      when: ssh_config_verify.rc != 0

    - name: Check if firewalld is running
      command: systemctl is-active firewalld
      register: firewalld_status
      changed_when: false
      failed_when: false
      when: ansible_os_family == "RedHat"

    - name: Ensure firewall allows SSH
      command: firewall-cmd --permanent --add-port={{ ansible_port | default(22) }}/tcp && firewall-cmd --reload
      when: 
        - ansible_os_family == "RedHat"
        - firewalld_status.rc == 0
      failed_when: false
      ignore_errors: yes

    - name: Ensure firewall blocks MariaDB from external access (MariaDB should not be exposed anyway)
      command: firewall-cmd --permanent --remove-port=3306/tcp 2>/dev/null; firewall-cmd --reload 2>/dev/null || true
      when: 
        - ansible_os_family == "RedHat"
        - firewalld_status.rc == 0
      changed_when: false
      failed_when: false

    - name: Final verification - Test MariaDB root access
      command: mysql -e "SELECT 'MariaDB is working correctly' AS status;"
      register: final_mariadb_test
      changed_when: false
      no_log: true

    - name: Final verification - Test student user database access
      command: mysql -u {{ item.key }} -p{{ item.value }} -e "USE {{ item.key }}; SELECT 'Database access works' AS status;"
      register: final_user_test
      changed_when: false
      failed_when: false
      no_log: true
      with_dict: "{{ student_users }}"

    - name: Display final status
      debug:
        msg: |
          ========================================
          Database Server Setup Complete!
          ========================================
          Host: {{ inventory_hostname }}
          MariaDB Status: {{ 'OK' if final_mariadb_test.rc == 0 else 'FAILED - Check logs' }}
          Student Users Created: {{ student_users.keys() | list | length }}
          Databases Created: {{ student_users.keys() | list | length }}
          ========================================
          Next steps:
          1. SSH into VM: ssh <user>@{{ inventory_hostname }}
          2. Test student access: ssh student1@{{ inventory_hostname }}
          3. Test database: mysql -u student1 -p

  handlers:
    - name: restart mariadb
      systemd:
        name: mariadb
        state: restarted

    - name: restart sshd
      systemd:
        name: sshd
        state: restarted
