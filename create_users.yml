---
# ============================================================================
# Standalone Playbook: Create Users and Databases
# ============================================================================
# This playbook can be run independently to create system users, MariaDB
# databases, and MariaDB users. It assumes the VM is already set up with
# MariaDB installed and configured.
#
# Usage:
#   ansible-playbook -i inventory_test.ini create_users.yml
#   ansible-playbook -i inventory_test.ini create_users.yml -e users_json_path="./custom_users.json"
# ============================================================================

- name: Setup SSH keys for hosts in inventory
  hosts: myhosts
  connection: local
  gather_facts: no
  vars:
    # SSH Connection Settings for initial key setup
    initial_ssh_user: "j"             # SSH username for initial key setup
    initial_ssh_password: "root"       # SSH password for initial key setup
    initial_ssh_port: 22               # SSH port (usually 22)
    
    # User creation settings
    users_json_path: "./users_to_create.json"
  
  tasks:
    - name: Get home directory
      shell: echo $HOME
      register: home_dir
      delegate_to: localhost
      changed_when: false

    - name: Set SSH key path
      set_fact:
        ssh_key_path: "{{ home_dir.stdout }}/.ssh/id_rsa_ansible_{{ inventory_hostname | replace('.', '_') }}"
      delegate_to: localhost

    - name: Check if SSH key exists for host
      stat:
        path: "{{ ssh_key_path }}"
      register: ssh_key_exists
      delegate_to: localhost

    - name: Generate SSH key pair for host if it doesn't exist
      openssh_keypair:
        path: "{{ ssh_key_path }}"
        type: rsa
        size: 2048
        comment: "ansible@{{ inventory_hostname }}"
      delegate_to: localhost
      when: not ssh_key_exists.stat.exists

    - name: Ensure .ssh directory has correct permissions (700)
      file:
        path: "{{ home_dir.stdout }}/.ssh"
        mode: '0700'
        state: directory
      delegate_to: localhost

    - name: Ensure private key has correct permissions (600)
      file:
        path: "{{ ssh_key_path }}"
        mode: '0600'
        state: file
      delegate_to: localhost

    - name: Ensure public key has correct permissions (644)
      file:
        path: "{{ ssh_key_path }}.pub"
        mode: '0644'
        state: file
      delegate_to: localhost

    - name: Read public key content for verification
      slurp:
        src: "{{ ssh_key_path }}.pub"
      register: public_key_content
      delegate_to: localhost

    - name: Check if SSH key already works
      shell: |
        ssh -i {{ ssh_key_path }} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -o ConnectTimeout=5 -p {{ initial_ssh_port }} {{ initial_ssh_user }}@{{ inventory_hostname }} 'echo "KEY_WORKS"' 2>&1
      delegate_to: localhost
      register: key_check
      changed_when: false
      failed_when: false

    - name: Get public key content as string
      set_fact:
        public_key_string: "{{ public_key_content.content | b64decode | trim }}"
      delegate_to: localhost

    - name: Add SSH key to authorized_keys on first login
      shell: |
        /usr/bin/expect << 'EXPECT_EOF'
        set timeout 30
        set exit_code 1
        log_user 0
        set pubkey "{{ public_key_string }}"
        spawn ssh -p {{ initial_ssh_port }} -o StrictHostKeyChecking=no {{ initial_ssh_user }}@{{ inventory_hostname }} "mkdir -p ~/.ssh && echo \"$pubkey\" >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys && echo 'KEY_ADDED'"
        expect {
          -re "(?i)password" {
            send "{{ initial_ssh_password }}\r"
            exp_continue
          }
          -re "yes/no" {
            send "yes\r"
            exp_continue
          }
          -re "KEY_ADDED" {
            set exit_code 0
          }
          timeout {
            set exit_code 1
          }
          eof {
            catch wait result
            set spawn_exit_code [lindex $result 3]
            if {$spawn_exit_code == 0} {
              set exit_code 0
            } elseif {$spawn_exit_code != ""} {
              set exit_code $spawn_exit_code
            }
          }
        }
        exit $exit_code
        EXPECT_EOF
      delegate_to: localhost
      register: key_add_result
      changed_when: key_add_result.rc == 0
      failed_when: false
      when: "'KEY_WORKS' not in key_check.stdout | default('')"

    - name: Get absolute path for SSH private key
      shell: readlink -f {{ ssh_key_path }} || echo {{ ssh_key_path }}
      register: ssh_key_abs_path
      delegate_to: localhost
      changed_when: false

    - name: Update host variables for SSH key authentication
      add_host:
        name: "{{ inventory_hostname }}"
        ansible_host: "{{ inventory_hostname }}"
        ansible_ssh_private_key_file: "{{ ssh_key_abs_path.stdout }}"
        ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes'
        ansible_port: "{{ initial_ssh_port }}"
        ansible_user: "{{ initial_ssh_user }}"
        ansible_connection: ssh
        ansible_become: yes
        ansible_become_method: sudo
        ansible_become_password: "{{ initial_ssh_password }}"
        groups: myhosts
        users_json_path: "{{ users_json_path }}"

- name: Create Users and Databases
  hosts: myhosts
  become: yes
  vars:
    users_json_path: "{{ hostvars[groups['myhosts'][0]]['users_json_path'] | default('./users_to_create.json') }}"
  
  tasks:
    - name: Verify MariaDB is running
      systemd:
        name: mariadb
        state: started
      failed_when: false

    - name: Check MariaDB connectivity
      command: mysql -e "SELECT 1;"
      register: mariadb_check
      changed_when: false
      failed_when: mariadb_check.rc != 0

    - name: Include create_users role
      include_role:
        name: create_users

    - name: Display completion message
      debug:
        msg: |
          ========================================
          User Creation Complete!
          ========================================
          The create_users role has finished executing.
          All users, databases, and MariaDB accounts have been created.
          ========================================


